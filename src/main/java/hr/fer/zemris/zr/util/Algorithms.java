package hr.fer.zemris.zr.util;

import hr.fer.zemris.zr.data.HOGImage;
import org.opencv.core.Mat;
import org.opencv.core.Size;
import org.opencv.imgproc.Imgproc;

import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.function.Consumer;

/**
 * A class containing algorithms used in image
 * processing and calculations.
 *
 * @author Mateo Imbri≈°ak
 */

public class Algorithms {

    private static final int MAX_ALPHA_INT = -16777216;

    /**
     * Don't let anyone instantiate this class.
     */
    private Algorithms() {}

    /**
     * Converts a {@link BufferedImage} to a {@code float} type {@code array}.
     * Size of the array is equal to width * height * number of bytes per pixel
     * (3 if image has on alpha channel, otherwise 4). Colors are ordered the
     * same way as they are in image's {@link DataBufferByte#getData()}.
     *
     * @param img image whose data is being processed.
     *
     * @return an array of {@code float} values that represent each pixel's color.
     */
    public static float[] getDataFloat(BufferedImage img) {
        final byte[] pixels = ((DataBufferByte) img.getRaster().getDataBuffer()).getData();
        final int width = img.getWidth();
        final int height = img.getHeight();
        final boolean hasAlpha = img.getAlphaRaster() != null;
        final int valuesPerPixel = hasAlpha ? 4 : 3;

        final int size = width * height * valuesPerPixel;
        float[] data = new float[size];

        for (int i = 0; i < size; i += valuesPerPixel) {
            for (int j = 0; j < valuesPerPixel; j++) {
                data[i + j] = (pixels[i + j] & 0xFF) / 255f;
            }
        }

        return data;
    }

    /**
     * Converts a {@link BufferedImage} to a {@code int} type {@code array}.
     * Size of the array is equal to width * height. Colors are ordered the
     * same way as they are in image's {@link DataBufferByte#getData()}.
     *
     * @param img image whose data is being processed.
     *
     * @return an array of {@code int} values that represent each pixel's color.
     */
    public static int[] getDataInt(BufferedImage img) {
        final byte[] pixels = ((DataBufferByte) img.getRaster().getDataBuffer()).getData();
        final int width = img.getWidth();
        final int height = img.getHeight();
        final boolean hasAlpha = img.getAlphaRaster() != null;

        final int size = width * height;
        int[] data = new int[size];

        int pixelCounter = 0;

        if (hasAlpha) {
            for (int i = 0; i < size; i++) {
                int rgb = 0;
                rgb += (((int) pixels[pixelCounter++] & 0xFF) << 24); // alpha
                rgb += ((int) pixels[pixelCounter++] & 0xFF); // blue
                rgb += (((int) pixels[pixelCounter++] & 0xFF) << 8); // green
                rgb += (((int) pixels[pixelCounter++] & 0xFF) << 16); // red

                data[i] = rgb;
            }
        } else {
            for (int i = 0; i < size; i++) {
                int rgb = MAX_ALPHA_INT;
                rgb += ((int) pixels[pixelCounter++] & 0xFF); // blue
                rgb += (((int) pixels[pixelCounter++] & 0xFF) << 8); // green
                rgb += (((int) pixels[pixelCounter++] & 0xFF) << 16); // red

                data[i] = rgb;
            }
        }

        return data;
    }

    /**
     * Calculates derivative of the image whose data is passed as {@code src}
     * in the direction defined by {@code direction}.
     *
     * @param src image data generated by {@link #getDataFloat(BufferedImage)}.
     * @param direction {@code x} or {@code y}.
     * @param width of the image.
     * @param height of the image.
     * @param pixelSize number of elements used to represent a pixel.
     * @param parallel whether the execution should be parallel or not.
     *
     * @return an {@code array} of {@code float} elements representing derivative
     *         in the given direction.
     */
    public static float[] derive(float[] src, char direction, int width, int height, int pixelSize, boolean parallel) {
        final int size = src.length;
        float[] dest = new float[size];

        if (parallel) {
            int processors = Runtime.getRuntime().availableProcessors();
            BlockingQueue<Integer> queue;
            Thread[] threads = new Thread[processors];
            int killElement = -1;

            switch (direction) {
                case 'x':
                    queue = initializeQueue(height, processors, killElement);
                    Consumer<Integer> derivativeX = integer -> deriveX(src, dest, width, pixelSize, integer);

                    for (int i = 0; i < processors; i++) {
                        threads[i] = new Thread(() -> deriveThread(queue, killElement, derivativeX));

                        threads[i].start();
                    }

                    joinThreads(threads);
                    break;
                case 'y':
                    queue = initializeQueue(width, processors, killElement);
                    Consumer<Integer> derivativeY = integer -> deriveY(src, dest, width, height, pixelSize, integer);

                    for (int i = 0; i < processors; i++) {
                        threads[i] = new Thread(() -> deriveThread(queue, killElement, derivativeY));

                        threads[i].start();
                    }

                    joinThreads(threads);
                    break;
                default:
                    throw new RuntimeException("Direction must be x or y.");
            }
        } else {
            switch (direction) {
                case 'x':
                    for (int i = 0; i < height; i++) {
                        deriveX(src, dest, width, pixelSize, i);
                    }
                    break;
                case 'y':
                    for (int i = 0; i < width; i++) {
                        deriveY(src, dest, width, height, pixelSize, i);
                    }
                    break;
                default:
                    throw new RuntimeException("Direction must be x or y.");
            }
        }

        return dest;
    }

    /**
     * Calculates the magnitude using given x and y derivatives.
     *
     * @param gx array containing x derivative.
     * @param gy array containing y derivative.
     *
     * @return an array containing calculated magnitude.
     */
    public static float[] calculateMagnitude(float[] gx, float[] gy) {
        if (gx.length != gy.length) {
            throw new RuntimeException("Both arrays must be of same length.");
        }

        final int length = gx.length;
        float[] magnitude = new float[length];

        for (int i = 0; i < length; i++) {
            float x = gx[i];
            float y = gy[i];

            magnitude[i] = (float) Math.sqrt(x * x + y * y);
        }

        return magnitude;
    }

    /**
     * Calculates the angle using given x and y derivatives.
     *
     * @param gx array containing x derivative.
     * @param gy array containing y derivative.
     *
     * @return an array containing calculated angle.
     */
    public static float[] calculateAngle(float[] gx, float[] gy) {
        if (gx.length != gy.length) {
            throw new RuntimeException("Both arrays must be of same length.");
        }

        final int length = gx.length;
        float[] magnitude = new float[length];

        for (int i = 0; i < length; i++) {
            float x = gx[i];
            float y = gy[i];

            float value = (float) Math.toDegrees(Math.atan2(y, x) % Math.PI);

            value += value < 0 ? 180 : 0;

            magnitude[i] = value;
        }

        return magnitude;
    }

    /**
     * Creates a {@link BufferedImage} from the given {@code data} array.
     *
     * @param data array containing pixel data.
     * @param width of the image.
     * @param height of the image.
     * @param colorType defines {@code imageType} of created {@link BufferedImage}.
     *
     * @return a new {@link BufferedImage} whose pixels are calculated from {@code data}.
     */
    public static BufferedImage convertToImage(float[] data, int width, int height, int colorType) {
        BufferedImage img = new BufferedImage(width, height, colorType);
        byte[] pixels = ((DataBufferByte) img.getRaster().getDataBuffer()).getData();

        int offset = 0;

        for (float color : data) {
            pixels[offset++] = (byte) (Math.round(Math.abs(color) * 255) & 0xFF);
        }

        return img;
    }

    /**
     * Creates a {@link List} of scaled images from the given image.
     *
     * @param image matrix that represents an image.
     * @param factor scaling factor used to resize the image.
     * @param minHeight height threshold used to stop the algorithm.
     * @param minWidth width threshold used to stop the algorithm.
     *
     * @return {@link List} of scaled images.
     */
    public static List<HOGImage> createPyramid(Mat image, double factor, int minHeight, int minWidth) {
        List<HOGImage> pyramid = new LinkedList<>();
        pyramid.add(toHOGImage(image));

        int width = image.width();
        int height = image.height();
        Mat nextImage = image;

        while (height / factor > minHeight && width / factor > minWidth) {
            nextImage = scaleMat(nextImage, factor);
            height = nextImage.height();
            width = nextImage.width();

            pyramid.add(toHOGImage(nextImage));
        }

        return pyramid;
    }

    /**
     * Scales the given {@link Mat} by {@code factor} and converts it to a {@link BufferedImage}.
     *
     * @param image original image in {@link Mat} format.
     * @param factor used to scale the image.
     * @param colorType used by the original image.
     *
     * @return a new scaled {@link BufferedImage}.
     */
    public static BufferedImage scaleImage(Mat image, double factor, int colorType) {
        final Mat scaled = scaleMat(image, factor);
        final float[] data = convertData(scaled);
        return convertToImage(data, scaled.width(), scaled.height(), colorType);
    }

    /**
     * Scales the given image using the given factor.
     *
     * @param image to be scaled.
     * @param factor used to scale the image.
     *
     * @return scaled image.
     */
    private static Mat scaleMat(Mat image, double factor) {
        Mat resized = new Mat();
        Imgproc.resize(image, resized, new Size(image.width() / factor, image.height() / factor));
        return resized;
    }

    /**
     * Converts the given {@link Mat} to a {@link HOGImage}.
     *
     * @param original image being converted.
     *
     * @return resulting {@link HOGImage}.
     */
    private static HOGImage toHOGImage(Mat original) {
        final int width = original.width();
        final int height = original.height();
        final int bytesPerPixel = original.channels();

        float[] pixels = convertData(original);

        float[] dx = derive(pixels, 'x', width, height, bytesPerPixel, true);
        float[] dy = derive(pixels, 'y', width, height, bytesPerPixel, true);

        return new HOGImage(calculateMagnitude(dx, dy), calculateAngle(dx, dy), width, height, bytesPerPixel);
    }

    /**
     * Converts {@link Mat} data to a {@code float array}.
     *
     * @param original {@link Mat} containing image data.
     *
     * @return a new {@code float array} containing data from the {@code original} {@link Mat}.
     */
    private static float[] convertData(Mat original) {
        final int width = original.width();
        final int height = original.height();
        final int bytesPerPixel = original.channels();

        float[] pixels = new float[(int) original.total() * bytesPerPixel];

        int index = 0;

        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                double[] data = original.get(i, j);

                for (int k = 0; k < bytesPerPixel; k++) {
                    pixels[index++] = (float) data[k] / 255;
                }
            }
        }

        return pixels;
    }

    /**
     * Used in methods that use multithreading. Causes main thread
     * to {@link Thread#join()} all threads in {@code threads}.
     *
     * @param threads that the main thread should join.
     */
    public static void joinThreads(Thread[] threads) {
        for (int i = 0, processors = threads.length; i < processors; i++) {
            try {
                threads[i].join();
            } catch (InterruptedException exc) {
                i--;
            }
        }
    }

    /**
     * Method that defines job done by {@link Thread}s in {@link #derive(float[], char, int, int, int, boolean)} method.
     *
     * @param queue containing indexes to derive.
     * @param killElement element used to terminate the thread.
     * @param derivative {@link Consumer} that contains derivative function.
     */
    private static void deriveThread(BlockingQueue<Integer> queue, int killElement, Consumer<Integer> derivative) {
        while (true) {
            int index;

            try {
                index = queue.take();
            } catch (InterruptedException exc) {
                continue;
            }

            if (index == killElement) {
                break;
            }

            derivative.accept(index);
        }
    }

    /**
     * Derivative in y axis direction.
     *
     * @param src {@code array} containing image data.
     * @param dest {@code array} in which calculations will be written.
     * @param width of the image.
     * @param height of the image.
     * @param pixelSize number of elements used per pixel.
     * @param column index of column being calculated.
     */
    private static void deriveY(float[] src, float[] dest, int width, int height, int pixelSize, int column) {
        int arrayWidth = pixelSize * width;
        int offset = arrayWidth + (column * pixelSize);

        for (int i = 1, limit = height - 1; i < limit; i++) {
            for (int j = 0; j < pixelSize; j++) {
                dest[offset + j] = -src[offset + j - arrayWidth] + src[offset + j + arrayWidth];
            }

            offset += arrayWidth;
        }
    }

    /**
     * Derivative in x axis direction.
     *
     * @param src {@code array} containing image data.
     * @param dest {@code array} in which calculations will be written.
     * @param width of the image.
     * @param pixelSize number of elements used per pixel.
     * @param row index of row being calculated.
     */
    private static void deriveX(float[] src, float[] dest, int width, int pixelSize, int row) {
        int offset = pixelSize * width * row + pixelSize;

        for (int i = 1; i < width - 1; i++) {
            for (int j = 0; j < pixelSize; j++) {
                dest[offset] = -src[offset - pixelSize] + src[offset + pixelSize];
                offset++;
            }
        }
    }

    /**
     * Initializes the Queue with indexes.
     *
     * @param numberOfElement number of indexes to be added.
     * @param processors number of {@code killElement}s to add.
     * @param killElement element used to stop the thread.
     *
     * @return a new {@link BlockingQueue} containing indexes
     *         {@code 0} through {@code numberOfElements - 1}
     *         and {@code processors} elements used to stop
     *         the threads.
     */
    public static BlockingQueue<Integer> initializeQueue(int numberOfElement, int processors, int killElement) {
        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(numberOfElement + processors);

        for (int i = 0; i < numberOfElement; i++) {
            queue.offer(i);
        }

        for (int i = 0; i < processors; i++) {
            queue.offer(killElement);
        }

        return queue;
    }

    /**
     * Initializes a {@link BlockingQueue} with indexes calculated by simulating
     * a sliding window with given {@code step} on an image with the given
     * {@code width} and {@code height} and defined minimum width and height.
     *
     * @param width of the image.
     * @param height of the image.
     * @param minWidth minimum width of the image.
     * @param minHeight minimum height of the image.
     * @param step used by the sliding window.
     * @param processors number of processors.
     * @param killElement element used to terminate a {@link Thread}.
     *
     * @return a {@link BlockingQueue} filled with valid indexes and
     *          defined number of kill elements at the end.
     */
    public static BlockingQueue<Integer> initializeQueue(int width, int height, int minWidth, int minHeight,
                                                         int step, int processors, int killElement) {
        return initializeQueue(calculateNumberOfWindows(width, height, minWidth, minHeight, step),
                processors, killElement);
    }

    /**
     * Calculates the number of sliding window positions for the given parameters.
     *
     * @param width of the image.
     * @param height of the image.
     * @param minWidth minimum width of the image.
     * @param minHeight minimum height of the image.
     * @param step used by the sliding window.
     *
     * @return number of sliding window positions.
     */
    public static int calculateNumberOfWindows(int width, int height, int minWidth, int minHeight, int step) {
        int counter = 0;

        for (int i = width; i >= minWidth; i -= step) {
            for (int j = height; j >= minHeight; j -= step) {
                counter++;
            }
        }

        return counter;
    }
}
